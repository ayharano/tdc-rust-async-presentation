<div>
    <h1>Saída assíncrona</h1>

<pre><code><span data-slide-steps="1-">pub trait AsyncWrite: Write {</span>
    <span data-slide-steps="2-">fn poll_write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;Async&lt;usize&gt;, Error&gt; { ... }</span>

    <span data-slide-steps="3-">fn poll_flush(&amp;mut self) -&gt; Result&lt;Async&lt;()&gt;, Error&gt; { ... }</span>

    <span data-slide-steps="4-">fn shutdown(&amp;mut self) -&gt; Result&lt;Async&lt;()&gt;, Error&gt;;</span>
<span data-slide-steps="1-">}</span>

<span data-slide-steps="5-">// Implementando AsyncWrite para MyWrite
impl Write for MyWrite {
    fn write(&amp;mut self, buf &amp;[u8]) -&gt; Result&lt;usize, tokio::io::Error&gt; {
        // Se for bloquear, precisa preparar a tarefa para ser acordada quando
        // for possível enviar mais dados, e depois retornar:

        Err(ErrorKind::WouldBlock.into())
    }

    fn flush(&amp;mut self) -&gt; Result&lt;(), tokio::io::Error&gt; {
        // Mesma necessidade aqui

        Err(ErrorKind::WouldBlock.into())
    }
}

impl AsyncWrite for MyWrite {</span>
    <span data-slide-steps="6-">fn shutdown(&amp;mut self) -&gt; Result&lt;Async&lt;()&gt;, Error&gt; {
        Ok(Async::Ready(()))
    }</span>
<span data-slide-steps="5-">}</span>
</code></pre>
</div>
