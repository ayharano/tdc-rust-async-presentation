<div>
    <h1>Implementando operações</h1>

<pre><code>pub trait Future {
    type Item;
    type Error;

    fn poll(&amp;mut self) -&gt; Result&lt;Async&lt;Self::Item&gt;, Self::Error&gt;;
}
</code></pre>

<pre><code>pub enum Async&lt;T&gt; {
    Ready(T),
    NotReady,
}
</code></pre>

    <ul>
        <li data-slide-steps="1-">Na maioria dos casos não é preciso implementar um <code>Future</code> manualmente</li>
        <li data-slide-steps="2-">Mesmo se necessário, geralmente é feito compondo outros <code>Future</code>s
            <ul>
                <li data-slide-steps="3-">Basta tomar o cuidado</li>
                <li data-slide-steps="4-">Retornar <code>Async::NotReady</code> se e <strong>somente se</strong> pelo
                menos um dos <code>Future</code>s usados internamente também tiver retornado <code>Async::NotReady</code></li>
                <li data-slide-steps="5-">Ou seja, algum <code>Future</code> interno se preparou para acordar a tarefa</li>
            </ul>
        </li>
    </ul>
</div>
